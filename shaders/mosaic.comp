#version 450
#extension GL_KHR_shader_subgroup_arithmetic : enable

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform sampler2D inputSampler1; // Source (Blocks to use)
layout(binding = 1) uniform sampler2D inputSampler2; // Target (Image to recreate)
layout(binding = 2, rgba8) uniform writeonly image2D outputImage;

// Shared memory for target block cache and final reduction
shared vec3 s_targetPixels[256]; 
shared float s_subgroupBestSADs[32];
shared uint s_subgroupBestIdxs[32];
shared uint s_finalBestIdx;

void main() {
    ivec2 imgSize = textureSize(inputSampler1, 0);
    ivec2 myBlockPos = ivec2(gl_WorkGroupID.xy);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    uint threadIndex = gl_LocalInvocationIndex;
    ivec2 targetPixelPos = myBlockPos * 16 + localCoord;
    ivec2 gridSize = (imgSize + 15) / 16;

    if (myBlockPos.x >= gridSize.x || myBlockPos.y >= gridSize.y) return;

    // 1. Cache Target Block into Shared Memory
    // Using texelFetch for integer-based, hardware-cached loads
    vec3 targetPixel = vec3(0.0);
    if (all(lessThan(targetPixelPos, imgSize))) {
        targetPixel = texelFetch(inputSampler2, targetPixelPos, 0).rgb;
    }
    s_targetPixels[threadIndex] = targetPixel;
    
    barrier();

    // 2. Distributed Search across Subgroups
    float myBestSAD = 1e20;
    uint myBestIdx = 0;
    uint totalBlocks = gridSize.x * gridSize.y;

    for (uint i = gl_SubgroupID; i < totalBlocks; i += gl_NumSubgroups) {
        uint by = i / gridSize.x;
        uint bx = i - (by * gridSize.x);
        ivec2 bBase = ivec2(bx, by) * 16;
        
        float currentBlockSAD = 0.0;

        // Threads in subgroup collaborate on searching block 'i'
        for (uint p = gl_SubgroupInvocationID; p < 256; p += gl_SubgroupSize) {
            ivec2 pCoord = ivec2(p & 0xF, p >> 4);
            ivec2 spPos = bBase + pCoord;
            
            // hardware-optimized fetch
            vec3 s = texelFetch(inputSampler1, spPos, 0).rgb;
            
            // SIMD Channel SAD
            currentBlockSAD += dot(abs(s_targetPixels[p] - s), vec3(1.0));
        }

        // Parallel reduction within subgroup
        currentBlockSAD = subgroupAdd(currentBlockSAD);

        if (subgroupElect()) {
            if (currentBlockSAD < myBestSAD) {
                myBestSAD = currentBlockSAD;
                myBestIdx = i;
            }
        }
    }

    // 3. Final Collaborative Reduction
    if (subgroupElect()) {
        s_subgroupBestSADs[gl_SubgroupID] = myBestSAD;
        s_subgroupBestIdxs[gl_SubgroupID] = myBestIdx;
    }

    barrier();

    if (threadIndex == 0) {
        float finalBestSAD = s_subgroupBestSADs[0];
        uint finalBestIdx = s_subgroupBestIdxs[0];
        uint numSubgroups = gl_NumSubgroups; 
        for (uint j = 1; j < numSubgroups; j++) {
            if (s_subgroupBestSADs[j] < finalBestSAD) {
                finalBestSAD = s_subgroupBestSADs[j];
                finalBestIdx = s_subgroupBestIdxs[j];
            }
        }
        s_finalBestIdx = finalBestIdx;
    }

    barrier();

    // 4. Final Export
    uint bestBY = s_finalBestIdx / gridSize.x;
    uint bestBX = s_finalBestIdx - (bestBY * gridSize.x);
    ivec2 bestSourcePixelPos = ivec2(bestBX, bestBY) * 16 + localCoord;

    if (all(lessThan(targetPixelPos, imgSize))) {
        vec4 color = texelFetch(inputSampler1, bestSourcePixelPos, 0);
        imageStore(outputImage, targetPixelPos, color);
    }
}
