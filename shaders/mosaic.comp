#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform readonly image2D inputImage1;
layout(binding = 1, rgba8) uniform readonly image2D inputImage2;
layout(binding = 2, rgba8) uniform writeonly image2D outputImage;

// Convert RGB to HSV
vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// Better color matching that preserves saturation and hue
float colorDistance(vec3 c1, vec3 c2) {
    // Convert to HSV for better perceptual matching
    vec3 hsv1 = rgb2hsv(c1);
    vec3 hsv2 = rgb2hsv(c2);
    
    // Weight: hue difference, saturation difference, and value difference
    float hueDiff = min(abs(hsv1.x - hsv2.x), 1.0 - abs(hsv1.x - hsv2.x)) * 2.0; // Hue wraps around
    float satDiff = abs(hsv1.y - hsv2.y);
    float valDiff = abs(hsv1.z - hsv2.z);
    
    // Weighted distance - prioritize hue and saturation to preserve vibrant colors
    return hueDiff * 2.0 + satDiff * 1.5 + valDiff * 0.5;
}

// Shared variable must be at global scope
shared ivec2 bestSourceBlock;

void main() {
    ivec2 imgSize = imageSize(inputImage1);
    ivec2 myBlockPos = ivec2(gl_WorkGroupID.xy);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    
    // Calculate grid dimensions
    ivec2 gridSize = (imgSize + ivec2(15, 15)) / 16;
    
    if (myBlockPos.x >= gridSize.x || myBlockPos.y >= gridSize.y) return;
    
    if (gl_LocalInvocationIndex == 0) {
        // Get the target color for this block (center pixel)
        vec3 targetColor = imageLoad(inputImage2, myBlockPos * 16 + ivec2(8, 8)).rgb;
        
        float bestDistance = 1e10;
        bestSourceBlock = ivec2(0, 0);
        
        // Search all source blocks to find the best match
        for (int y = 0; y < gridSize.y; y++) {
            for (int x = 0; x < gridSize.x; x++) {
                ivec2 sourceBlockPos = ivec2(x, y);
                vec3 sourceColor = imageLoad(inputImage1, sourceBlockPos * 16 + ivec2(8, 8)).rgb;
                
                float dist = colorDistance(targetColor, sourceColor);
                if (dist < bestDistance) {
                    bestDistance = dist;
                    bestSourceBlock = sourceBlockPos;
                }
            }
        }
    }
    
    barrier(); // Wait for best match to be found
    
    // All threads copy pixels from the best matching source block
    ivec2 sourcePixel = bestSourceBlock * 16 + localCoord;
    ivec2 destPixel = myBlockPos * 16 + localCoord;
    
    // Bounds check
    if (sourcePixel.x < imgSize.x && sourcePixel.y < imgSize.y &&
        destPixel.x < imgSize.x && destPixel.y < imgSize.y) {
        vec4 color = imageLoad(inputImage1, sourcePixel);
        imageStore(outputImage, destPixel, color);
    }
}