#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform readonly image2D inputImage1;
layout(binding = 1, rgba8) uniform readonly image2D inputImage2;
layout(binding = 2, rgba8) uniform writeonly image2D outputImage;

float colorDistance(vec3 c1, vec3 c2) {
    return length(c1 - c2);
}

// Shared variable must be at global scope
shared ivec2 bestSourceBlock;

void main() {
    ivec2 imgSize = imageSize(inputImage1);
    ivec2 myBlockPos = ivec2(gl_WorkGroupID.xy);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    
    // Calculate grid dimensions
    ivec2 gridSize = (imgSize + ivec2(15, 15)) / 16;
    
    if (myBlockPos.x >= gridSize.x || myBlockPos.y >= gridSize.y) return;
    
    if (gl_LocalInvocationIndex == 0) {
        // Get the target color for this block (center pixel)
        vec3 targetColor = imageLoad(inputImage2, myBlockPos * 16 + ivec2(8, 8)).rgb;
        
        float bestDistance = 1e10;
        bestSourceBlock = ivec2(0, 0);
        
        // Search all source blocks to find the best match
        for (int y = 0; y < gridSize.y; y++) {
            for (int x = 0; x < gridSize.x; x++) {
                ivec2 sourceBlockPos = ivec2(x, y);
                vec3 sourceColor = imageLoad(inputImage1, sourceBlockPos * 16 + ivec2(8, 8)).rgb;
                
                float dist = colorDistance(targetColor, sourceColor);
                if (dist < bestDistance) {
                    bestDistance = dist;
                    bestSourceBlock = sourceBlockPos;
                }
            }
        }
    }
    
    barrier(); // Wait for best match to be found
    
    // All threads copy pixels from the best matching source block
    ivec2 sourcePixel = bestSourceBlock * 16 + localCoord;
    ivec2 destPixel = myBlockPos * 16 + localCoord;
    
    // Bounds check
    if (sourcePixel.x < imgSize.x && sourcePixel.y < imgSize.y &&
        destPixel.x < imgSize.x && destPixel.y < imgSize.y) {
        vec4 color = imageLoad(inputImage1, sourcePixel);
        imageStore(outputImage, destPixel, color);
    }
}