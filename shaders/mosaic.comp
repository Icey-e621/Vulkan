#version 450
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_ballot : enable 
#extension GL_KHR_shader_subgroup_vote : enable 
#extension GL_KHR_shader_subgroup_shuffle : enable

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform sampler2D inputSampler1;
layout(binding = 1) uniform sampler2D inputSampler2;
layout(binding = 2, rgba8) uniform writeonly image2D outputImage;
layout(binding = 3) uniform sampler2D sourceMeanSampler;
layout(binding = 4) uniform sampler2D targetMeanSampler;

// Optimization: Consolidated vec3 reduces the number of shared memory load instructions
shared vec3 s_targetPixels[256];

// Optimization: Tight bounds for pruning
shared float s_subgroupTightBound[8]; 

// Inter-subgroup reduction
shared float s_subgroupBestSADs[32];
shared uint s_subgroupBestIdxs[32];
shared uint s_finalBestIdx;

void main() {
    ivec2 imgSize = textureSize(inputSampler1, 0);
    ivec2 myBlockPos = ivec2(gl_WorkGroupID.xy);
    uint threadIndex = gl_LocalInvocationIndex;
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    ivec2 targetPixelPos = myBlockPos * 16 + localCoord;
    ivec2 gridSize = (imgSize + 15) / 16;
    uint subgroupID = gl_SubgroupID;

    if (myBlockPos.x >= gridSize.x || myBlockPos.y >= gridSize.y) return;

    // 1. Load data
    vec3 targetMean = texelFetch(targetMeanSampler, myBlockPos, 0).rgb;
    
    vec3 pix = vec3(0.0);
    if (all(lessThan(targetPixelPos, imgSize))) {
        pix = texelFetch(inputSampler2, targetPixelPos, 0).rgb;
    }
    s_targetPixels[threadIndex] = pix;
    
    barrier();

    // 2. Setup Pruning
    uint totalBlocks = gridSize.x * gridSize.y;
    uint gWidth = gridSize.x;
    
    vec3 mySelfMean = texelFetch(sourceMeanSampler, myBlockPos, 0).rgb;
    float currentBound = dot(abs(targetMean - mySelfMean), vec3(256.0)) + 1.0; 
    uint localBestIdx = uint(myBlockPos.y * gWidth + myBlockPos.x);

    // 3. Search Loop (Leaner & Faster)
    uint step = gl_NumSubgroups;
    uint i = gl_SubgroupID; 
    uint bx = i % gWidth;
    uint by = i / gWidth;

    for (; i < totalBlocks; i += step) {
        vec3 sourceMean = texelFetch(sourceMeanSampler, ivec2(bx, by), 0).rgb;
        float meanSAD256 = dot(abs(targetMean - sourceMean), vec3(256.0));

        // Use 'subgroupAny' to keep the subgroup moving together (reduces divergence)
        if (subgroupAny(meanSAD256 < currentBound)) {
            ivec2 bBase = ivec2(bx, by) << 4; 
            
            // --- COARSE PIXEL CHECK ---
            float coarseSAD = 0.0;
            for (uint p = gl_SubgroupInvocationID; p < 64; p += gl_SubgroupSize) {
                uint pIdx = p << 2;
                vec3 s_pix = texelFetch(inputSampler1, bBase + ivec2(pIdx & 0xF, pIdx >> 4), 0).rgb;
                coarseSAD += dot(abs(s_targetPixels[pIdx] - s_pix), vec3(1.0));
            }
            coarseSAD = subgroupAdd(coarseSAD);
            
            // Tighten the check: only do full SAD if coarse check is promising
            if (subgroupAny(coarseSAD * 4.0 < currentBound)) {
                float fullSAD = 0.0;
                for (uint p = gl_SubgroupInvocationID; p < 256; p += gl_SubgroupSize) {
                    vec3 s_pix = texelFetch(inputSampler1, bBase + ivec2(p & 0xF, p >> 4), 0).rgb;
                    fullSAD += dot(abs(s_targetPixels[p] - s_pix), vec3(1.0));
                }
                fullSAD = subgroupAdd(fullSAD);

                if (fullSAD < currentBound) {
                    currentBound = fullSAD;
                    localBestIdx = i;
                }
                // Sync the best result within the subgroup
                float bestInSub = subgroupMin(currentBound);
                currentBound = bestInSub; 
            }
        }

        // IMPROVED ADDRESS MATH: Avoid % and / inside the hot loop
        bx += step;
        if (bx >= gWidth) {
            bx -= gWidth;
            by += 1;
            // Handle cases where step > gWidth (rare but possible)
            while (bx >= gWidth) { bx -= gWidth; by += 1; }
        }
    }

    
    // --- 4 & 5. COMBINED REDUCTION ---
    float subMinSAD = subgroupMin(currentBound);
    uvec4 winnerBallot = subgroupBallot(currentBound == subMinSAD);
    uint winnerLane = subgroupBallotFindLSB(winnerBallot); 
    uint subBestIdx = subgroupShuffle(localBestIdx, winnerLane);

    if (subgroupElect()) {
        s_subgroupBestSADs[subgroupID] = subMinSAD;
        s_subgroupBestIdxs[subgroupID] = subBestIdx;
    }
    barrier();

    // Final Pick (Cleaned up redundant block)
    if (subgroupID == 0) {
        bool isValid = threadIndex < gl_NumSubgroups;
        float finalSAD = isValid ? s_subgroupBestSADs[threadIndex] : 1e20;
        uint finalIdx = isValid ? s_subgroupBestIdxs[threadIndex] : 0;
        
        float wgMin = subgroupMin(finalSAD);
        uvec4 wgWinnerBallot = subgroupBallot(finalSAD == wgMin && isValid);
        uint wgWinnerLane = subgroupBallotFindLSB(wgWinnerBallot);
        
        uint winnerFinalIdx = subgroupShuffle(finalIdx, wgWinnerLane);
        if (subgroupElect()) s_finalBestIdx = winnerFinalIdx;
    }
    barrier();

    // 6. Final Export
    uint resBY = s_finalBestIdx / gWidth;
    uint resBX = s_finalBestIdx % gWidth;
    ivec2 sourceCoord = (ivec2(resBX, resBY) << 4) + localCoord;

    if (all(lessThan(targetPixelPos, imgSize))) {
        vec4 color = texelFetch(inputSampler1, sourceCoord, 0);
        imageStore(outputImage, targetPixelPos, color);
    }
}