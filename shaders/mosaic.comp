#version 450
#extension GL_KHR_shader_subgroup_arithmetic : enable

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform readonly image2D inputImage1; // Source (Blocks to use)
layout(binding = 1, rgba8) uniform readonly image2D inputImage2; // Target (Image to recreate)
layout(binding = 3, rgba8) uniform writeonly image2D outputImage;

// Shared memory for reduction
shared vec3 s_targetPixels[256];
shared float s_subgroupSADs[32]; 
shared float s_bestSAD;
shared uint s_bestIdx;

void main() {
    ivec2 imgSize = imageSize(inputImage1);
    ivec2 myBlockPos = ivec2(gl_WorkGroupID.xy);
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    uint threadIndex = gl_LocalInvocationIndex;
    
    ivec2 targetPixelPos = myBlockPos * 16 + localCoord;
    
    // 1. Load the target block into shared memory once
    vec3 targetPixel = vec3(0.0);
    if (targetPixelPos.x < imgSize.x && targetPixelPos.y < imgSize.y) {
        targetPixel = imageLoad(inputImage2, targetPixelPos).rgb;
    }
    s_targetPixels[threadIndex] = targetPixel;
    
    if (threadIndex == 0) {
        s_bestSAD = 1e20;
        s_bestIdx = 0;
    }
    
    barrier();
    
    // Bounds check for the whole workgroup block
    ivec2 gridSize = (imgSize + ivec2(15, 15)) / 16;
    if (myBlockPos.x >= gridSize.x || myBlockPos.y >= gridSize.y) return;
    
    uint totalBlocks = gridSize.x * gridSize.y;
    
    // 2. Iterate through all source blocks and calculate SAD
    for (uint i = 0; i < totalBlocks; i++) {
        uint by = i / gridSize.x;
        uint bx = i - (by * gridSize.x);
        
        ivec2 sourcePixelPos = ivec2(bx, by) * 16 + localCoord;
        
        // Load source pixel
        vec3 sourcePixel = vec3(0.0);
        if (sourcePixelPos.x < imgSize.x && sourcePixelPos.y < imgSize.y) {
            sourcePixel = imageLoad(inputImage1, sourcePixelPos).rgb;
        }
        
        // Calculate Absolute Difference for this pixel/thread
        vec3 diff = abs(targetPixel - sourcePixel);
        float pixelSAD = diff.r + diff.g + diff.b;
        
        // Use subgroup operations (SIMD) to sum SAD within subgroups
        float groupSum = subgroupAdd(pixelSAD);
        
        // Collaborative reduction: store subgroup sums in shared memory
        if (subgroupElect()) {
            s_subgroupSADs[gl_SubgroupID] = groupSum;
        }
        
        barrier(); // Sync subgroup sums
        
        // Thread 0 of first subgroup finishes the reduction across subgroups
        if (gl_SubgroupID == 0) {
            float totalSAD = (threadIndex < gl_NumSubgroups) ? s_subgroupSADs[threadIndex] : 0.0;
            totalSAD = subgroupAdd(totalSAD);
            
            if (threadIndex == 0) {
                if (totalSAD < s_bestSAD) {
                    s_bestSAD = totalSAD;
                    s_bestIdx = i;
                }
            }
        }
        
        barrier(); // Sync best match update before next iteration
    }
    
    // 3. Thread 0 has found the best matching block index
    uint finalBestIdx = s_bestIdx;
    
    // Convert back to coordinates
    uint bestBY = finalBestIdx / gridSize.x;
    uint bestBX = finalBestIdx - (bestBY * gridSize.x);
    ivec2 bestSourceBlock = ivec2(bestBX, bestBY);
    ivec2 bestSourcePixelPos = bestSourceBlock * 16 + localCoord;
    
    // All threads copy their respective pixels from the best matching source block
    if (targetPixelPos.x < imgSize.x && targetPixelPos.y < imgSize.y &&
        bestSourcePixelPos.x < imgSize.x && bestSourcePixelPos.y < imgSize.y) {
        vec4 color = imageLoad(inputImage1, bestSourcePixelPos);
        imageStore(outputImage, targetPixelPos, color);
    }
}
